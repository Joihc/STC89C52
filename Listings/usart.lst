C51 COMPILER V9.57.0.0   USART                                                             06/07/2018 09:40:57 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE USART
OBJECT MODULE PLACED IN .\Objects\usart.obj
COMPILER INVOKED BY: D:\pro\keil5\core\C51\BIN\C51.EXE source\usart.c LARGE OPTIMIZE(9,SPEED) BROWSE INCDIR(.\include) D
                    -EBUG OBJECTEXTEND PRINT(.\Listings\usart.lst) TABS(2) OBJECT(.\Objects\usart.obj)

line level    source

   1          #define USART_C_
   2          #include "usart.h"
   3          
   4          
   5          //------------------串口通信协议-----------------//
   6          /*
   7              接收B01_00_0000000#
   8              发送A01_00_0000000#
   9          */
  10          uint8 buf_string[16];               //接收数据
  11          #define deviceID_1Bit '0'           //用于串口通信时，定义本地设备ID的第1位
  12          #define deviceID_2Bit '1'           //用于串口通信时，定义本地设备ID的第2位
  13          #define Service_headflag 'A'        //用于串口通信时，定义数据包头部的验证标记  表示服务器包  发送给服务器
             -的
  14          #define Clinet_headflag 'B'         //用于串口通信时，定义数据包头部的验证标记  表示客户端包  客户需要端接收的
  15          
  16          #define deviceID "01"
  17          
  18          //7-13 为数据 均*100
  19          //数据-9999.99~+9999.99
  20          uint8 DataPackage[16]={Service_headflag,deviceID_1Bit,deviceID_2Bit,'_','0','1','_','X','X','X','X','X','X
             -','X','#'};
  21          uint8 HeartBeat[16]={Service_headflag,deviceID_1Bit,deviceID_2Bit,'_','X','X','_','0','0','0','0','0','0',
             -'0','#'};
  22          
  23          int16 trans_int;
  24          uint8 trans_str[7];
  25          
  26          struct FifoQueue usart_queue;//串口通信仓库
  27          
  28          void Usart_Update()
  29          {
  30   1        if(Take_Queue(buf_string))
  31   1        {
  32   2          Deal_UART_RecData();
  33   2        }
  34   1      }
  35          void Send_To_Client_Packet(int8 index,int32 num)
  36          {
  37   1        uint32 buf = abs(num);
  38   1        DataPackage[4]=0x30+index%100/10;
  39   1        DataPackage[5]= 0x30+index%10;
  40   1        
  41   1        DataPackage[7] = (num<0?'-':'+');
  42   1        DataPackage[8] = 0x30+buf%1000000/100000;
  43   1        DataPackage[9] = 0x30+buf%100000/10000;
  44   1        DataPackage[10]= 0x30+buf%10000/1000;
  45   1        DataPackage[11]= 0x30+buf%1000/100;
  46   1        DataPackage[12]= 0x30+buf%100/10;
  47   1        DataPackage[13]= 0x30+buf%10;
  48   1          
  49   1        ES=0; //关闭接收中断
  50   1        for(buf=0;buf<15;buf++)
  51   1        {
C51 COMPILER V9.57.0.0   USART                                                             06/07/2018 09:40:57 PAGE 2   

  52   2          SBUF = DataPackage[buf];
  53   2          while(TI==0);
  54   2          TI=0;  
  55   2        }
  56   1        ES=1; 
  57   1      }  
  58          
  59          void SendHeartBeadPacket()
  60          {
  61   1        uint8 i;
  62   1        ES=0; //关闭接收中断
  63   1        for(i=0;i<15;i++)
  64   1        {
  65   2          SBUF = HeartBeat[i];
  66   2          while(TI==0);
  67   2          TI=0;  
  68   2        }
  69   1        ES=1; 
  70   1      }
  71          //定时器1用作波特率发生器
  72          void Init_USART()  
  73          {
  74   1          SCON=0x50;  //串口方式1，使能接收
  75   1          TMOD|=0x20;  //定时器1工作方式2（8位自动重装初值）
  76   1          TMOD&=~0x10;
  77   1          TH1=0xf3;   // 计数器初始值设置，注意波特率是4800的  12M晶振
  78   1          TL1=0xf3;  
  79   1          PCON|=0x80;  //SMOD=1
  80   1          TR1=1;
  81   1          TI=0;
  82   1          RI=0;
  83   1          //PS=1;   //提高串口中断优先级
  84   1          ES=1;  //开启串口中断使能
  85   1        
  86   1          QueueInit(&usart_queue);
  87   1      }
  88          //装入数据
  89          void Interrupt_Queue(uint8 sbuf)
  90          {
  91   1        QueueIn(&usart_queue,sbuf);
  92   1      }
  93          //取出B字开头的15个数据
  94          uint8 Take_Queue(uint8 *newchar)
  95          {
  96   1        uint8 i =0;
  97   1        uint8 temp;
  98   1        if(usart_queue.count < 15)
  99   1        {
 100   2          return 0;//不足15个数据
 101   2        }
 102   1        while(i<15 && QueueOut(&usart_queue,&temp) != QueueEmpty)
 103   1        {
 104   2          if(temp == Clinet_headflag || i != 0)
 105   2          {
 106   3            newchar[i] = temp;
 107   3            i++;
 108   3          }
 109   2        }
 110   1        if(i==15)//取了完整的数据
 111   1        {
 112   2          return 1;
 113   2        }
C51 COMPILER V9.57.0.0   USART                                                             06/07/2018 09:40:57 PAGE 3   

 114   1        return 0;
 115   1      }
 116          //比较指令尾部(start:从哪里开始比较，quality:比较多少个字符，CMD_tail[]：要比较的字符串)
 117          bit CompareCMD_tail(unsigned char start,unsigned char quality,char CMD_tail[]) 
 118          {
 119   1          unsigned char CharNum;
 120   1          for(CharNum=0;CharNum<quality;CharNum++)
 121   1          {
 122   2              if(!(buf_string[start+CharNum]==CMD_tail[CharNum]))
 123   2              {
 124   3                  return 0; 
 125   3              }
 126   2          }
 127   1          return 1;
 128   1      }
 129          
 130          bit Deal_UART_RecData()   //处理串口接收数据包函数（成功处理数据包则返回1，否则返回0）
 131          { 
 132   1        //清除发送完成标志位
 133   1      //    == 00  当前功率
 134   1      //    == 01  供电电压
 135   1      //    == 02  供电电流
 136   1      //    == 03  线盘电流
 137   1      //    == 04  最大电流
 138   1      //    == 05  线盘温度
 139   1      //    == 06  锅内温度
 140   1      //    == 07  IGBT频率
 141   1      //    == 08  IGBT温度
 142   1      //    == 09  使用容量
 143   1      //    == 10  机器状态
 144   1      //  
 145   1      //    == 50   输入密码
 146   1      //    == 51   最大功率  
 147   1      //    == 52   最大供电电压
 148   1      //    == 53   最小供电电压
 149   1      //    == 54   最大线盘电流
 150   1      //    == 55   最大线盘温度
 151   1      //    == 56   通用线盘温度
 152   1      //    == 57   最大锅内温度    
 153   1      //    == 58   最大漏料温度  
 154   1      //    == 59   最大IGBT频率
 155   1      //    == 60   最小IGBT频率
 156   1      //    == 61   最大IGBT温度
 157   1      //    == 62   限制工作时间
 158   1      //    == 63   修改密码  
 159   1        if(buf_string[0]==Clinet_headflag&&buf_string[14]=='#')  //进行数据包头尾标记验证
 160   1        {        
 161   2          if(CompareCMD_tail(1,2,deviceID))
 162   2          {
 163   3            strncpy(trans_str,buf_string+7,7);
 164   3            trans_int = my_atoi(trans_str);
 165   3            if(CompareCMD_tail(4,2,"00"))     //    == 00  当前功率
 166   3            {
 167   4              Set_Menu1_Value(0,trans_int);
 168   4              //send_PC('a');
 169   4            }
 170   3            else if(CompareCMD_tail(4,2,"01"))//    == 01  供电电压
 171   3            {
 172   4              Set_Menu1_Value(1,trans_int);
 173   4              //send_PC('b');
 174   4            }
 175   3            else if(CompareCMD_tail(4,2,"02"))//    == 02  供电电流
C51 COMPILER V9.57.0.0   USART                                                             06/07/2018 09:40:57 PAGE 4   

 176   3            {
 177   4              Set_Menu1_Value(2,trans_int);
 178   4              //send_PC('c');
 179   4            }
 180   3            else if(CompareCMD_tail(4,2,"03"))//    == 03  线盘电流
 181   3            {
 182   4              Set_Menu1_Value(3,trans_int);
 183   4            }
 184   3            else if(CompareCMD_tail(4,2,"04"))//    == 04  最大电流
 185   3            {
 186   4              Set_Menu1_Value(4,trans_int);
 187   4            }
 188   3            else if(CompareCMD_tail(4,2,"05"))//    == 05  线盘温度
 189   3            {
 190   4              Set_Menu1_Value(5,trans_int);
 191   4            }
 192   3            else if(CompareCMD_tail(4,2,"06"))//    == 06  锅内温度
 193   3            {
 194   4              Set_Menu1_Value(6,trans_int);
 195   4            }
 196   3            else if(CompareCMD_tail(4,2,"07"))//    == 07  IGBT频率
 197   3            {
 198   4              Set_Menu1_Value(7,trans_int);
 199   4            }
 200   3            else if(CompareCMD_tail(4,2,"08"))//    == 08  IGBT温度
 201   3            {
 202   4              Set_Menu1_Value(8,trans_int);
 203   4            }
 204   3            else if(CompareCMD_tail(4,2,"09"))//    == 09  使用容量
 205   3            {
 206   4              Set_Menu1_Value(9,trans_int);
 207   4            }
 208   3            else if(CompareCMD_tail(4,2,"10"))//    == 10  机器状态
 209   3            {
 210   4              Set_Menu1_Value(10,trans_int);
 211   4            }
 212   3            else if(CompareCMD_tail(4,2,"50"))//    == 50   输入密码
 213   3            {
 214   4              Set_Menu2_Value(0,trans_int);                           
 215   4            }
 216   3            else if(CompareCMD_tail(4,2,"51"))//    == 51   最大功率
 217   3            {
 218   4              Set_Menu2_Value(1,trans_int);                               
 219   4            }  
 220   3            else if(CompareCMD_tail(4,2,"52"))//    == 52   最大供电电压
 221   3            {
 222   4              Set_Menu2_Value(2,trans_int); 
 223   4            }
 224   3            else if(CompareCMD_tail(4,2,"53"))//    == 53   最小供电电压
 225   3            {
 226   4              Set_Menu2_Value(3,trans_int); 
 227   4            }
 228   3            else if(CompareCMD_tail(4,2,"54"))//    == 54   最大线盘电流
 229   3            {
 230   4              Set_Menu2_Value(4,trans_int); 
 231   4            }
 232   3            else if(CompareCMD_tail(4,2,"55"))//    == 55   最大线盘温度
 233   3            {
 234   4              Set_Menu2_Value(5,trans_int); 
 235   4            }
 236   3            else if(CompareCMD_tail(4,2,"56"))//    == 56   通用线盘温度
 237   3            {
C51 COMPILER V9.57.0.0   USART                                                             06/07/2018 09:40:57 PAGE 5   

 238   4              Set_Menu2_Value(6,trans_int); 
 239   4            }
 240   3            else if(CompareCMD_tail(4,2,"57"))//    == 57   最大锅内温度
 241   3            {
 242   4              Set_Menu2_Value(7,trans_int); 
 243   4            }       
 244   3            else if(CompareCMD_tail(4,2,"58"))//    == 58   最大漏料温度  
 245   3            {
 246   4              Set_Menu2_Value(8,trans_int); 
 247   4            }
 248   3            else if(CompareCMD_tail(4,2,"59"))//    == 59   最大IGBT频率
 249   3            {
 250   4              Set_Menu2_Value(9,trans_int); 
 251   4            }
 252   3            else if(CompareCMD_tail(4,2,"60"))//    == 60   最小IGBT频率
 253   3            {
 254   4              Set_Menu2_Value(10,trans_int);  
 255   4            }
 256   3            else if(CompareCMD_tail(4,2,"61"))//    == 61   最大IGBT温度
 257   3            {
 258   4              Set_Menu2_Value(11,trans_int);  
 259   4            }
 260   3            else if(CompareCMD_tail(4,2,"62"))//    == 62   限制工作时间
 261   3            {
 262   4              Set_Menu2_Value(12,trans_int);  
 263   4            }
 264   3            else if(CompareCMD_tail(4,2,"63"))//    == 63   恢复出厂设置
 265   3            {
 266   4              Set_Menu2_Value(13,trans_int);  
 267   4            }       
 268   3          }
 269   2        }
 270   1        return 0;
 271   1      }
 272          
 273          
 274          void send_PC(int8 ch)
 275          {
 276   1          SBUF = ch;
 277   1          while(TI==0);
 278   1          TI=0;
 279   1      }
 280          
 281          
 282          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1292    ----
   CONSTANT SIZE    =     75    ----
   XDATA SIZE       =    123      19
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
