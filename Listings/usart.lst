C51 COMPILER V9.57.0.0   USART                                                             05/31/2018 15:56:47 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE USART
OBJECT MODULE PLACED IN .\Objects\usart.obj
COMPILER INVOKED BY: D:\pro\keil5\core\C51\BIN\C51.EXE source\usart.c LARGE OPTIMIZE(9,SPEED) BROWSE INCDIR(.\include) D
                    -EBUG OBJECTEXTEND PRINT(.\Listings\usart.lst) TABS(2) OBJECT(.\Objects\usart.obj)

line level    source

   1          #define USART_C_
   2          #include "usart.h"
   3          
   4          
   5          //------------------串口通信协议-----------------//
   6          /*
   7              接收A01_00_0000000#
   8              发送B01_00_0000000#
   9          */
  10          int8 buf_string[16];                //发送数据
  11          #define deviceID_1Bit '0'           //用于串口通信时，定义本地设备ID的第1位
  12          #define deviceID_2Bit '1'           //用于串口通信时，定义本地设备ID的第2位
  13          #define Service_headflag 'A'        //用于串口通信时，定义数据包头部的验证标记  表示服务器包  发送给服务器
             -的
  14          #define Clinet_headflag 'B'         //用于串口通信时，定义数据包头部的验证标记  表示客户端包  客户需要端接收的
  15          
  16          #define deviceID "01"
  17          
  18          //7-13 为数据 均*100
  19          //数据-9999.99~+9999.99
  20          int8 DataPackage[16]={Service_headflag,deviceID_1Bit,deviceID_2Bit,'_','0','1','_','X','X','X','X','X','X'
             -,'X','#'};
  21          int8 HeartBeat[16]={Service_headflag,deviceID_1Bit,deviceID_2Bit,'_','B','e','a','t','X','X','X','X','X','
             -X','#'};
  22          
  23          int16 trans_int;
  24          int8 trans_str[7];
  25          //----------------------------------------------//
  26          //客户端包描述 10-13  参数只有加(1)减(0)
  27          /* 
  28          str == 00  当前功率
  29              == 01  供电电压
  30              == 02  供电电流
  31              == 03  线盘电流
  32              == 04  最大电流
  33              == 05  线盘温度
  34              == 06  锅内温度
  35              == 07  IGBT频率
  36              == 08  IGBT温度
  37              == 09  使用容量
  38              == 10  机器状态
  39          
  40          
  41          str1 == 40 密码
  42          
  43          
  44          
  45          
  46          str2 ==80
  47          */
  48          void Send_To_Client_Packet(int8 index,int32 num)
  49          {
  50   1        uint32 buf = abs(num);
  51   1        DataPackage[4]=0x30+index%100/10;
C51 COMPILER V9.57.0.0   USART                                                             05/31/2018 15:56:47 PAGE 2   

  52   1        DataPackage[5]= 0x30+index%10;
  53   1        
  54   1        DataPackage[7] = (num<0?'-':'+');
  55   1        DataPackage[8] = 0x30+buf%1000000/100000;
  56   1        DataPackage[9] = 0x30+buf%100000/10000;
  57   1        DataPackage[10]= 0x30+buf%10000/1000;
  58   1        DataPackage[11]= 0x30+buf%1000/100;
  59   1        DataPackage[12]= 0x30+buf%100/10;
  60   1        DataPackage[13]= 0x30+buf%10;
  61   1          
  62   1        ES=0; //关闭接收中断
  63   1        for(buf=0;buf<15;buf++)
  64   1        {
  65   2          SBUF = DataPackage[buf];
  66   2          while(TI==0);
  67   2          TI=0;  
  68   2        }
  69   1        ES=1; 
  70   1      }                                               
  71          //串口接收函数
  72          bit ReceiveServicePacket()    
  73          {
  74   1          char *RecStr=buf_string;
  75   1          char num=0;
  76   1          unsigned int count=0;
  77   1          loop:    
  78   1          *RecStr=SBUF;
  79   1          count=0;
  80   1          RI=0; 
  81   1          if(num<14)  //数据包长度为15个字符,尝试连续接收15个字符
  82   1          {
  83   2              num++;
  84   2              RecStr++;    
  85   2              while(!RI)
  86   2              {
  87   3                  count++;
  88   3                  if(count>1000)
  89   3                  {
  90   4                    return 0;    //接收数据等待延迟，等待时间太久会导致CPU运算闲置，太短会出现"数据包被分割",默认count=
             -130
  91   4                  }
  92   3              }
  93   2              goto loop;
  94   2          }
  95   1          return 1;
  96   1      }
  97          //定时器1用作波特率发生器
  98          void Init_USART()  
  99          {
 100   1          SCON=0x50;  //串口方式1，使能接收
 101   1          TMOD|=0x20;  //定时器1工作方式2（8位自动重装初值）
 102   1          TMOD&=~0x10;
 103   1          TH1=0xf3;   // 计数器初始值设置，注意波特率是4800的  12M晶振
 104   1          TL1=0xf3;  
 105   1          PCON|=0x80;  //SMOD=1
 106   1          TR1=1;
 107   1          TI=0;
 108   1          RI=0;
 109   1          //PS=1;   //提高串口中断优先级
 110   1          ES=1;  //开启串口中断使能
 111   1      }
 112          //比较指令头部
C51 COMPILER V9.57.0.0   USART                                                             05/31/2018 15:56:47 PAGE 3   

 113          bit CompareCMD_head(char CMD_head[])    
 114          {
 115   1          unsigned char CharNum;
 116   1          for(CharNum=0;CharNum<4;CharNum++)  //指令长度为10个字符
 117   1          {
 118   2              if(!(buf_string[CharNum+4]==CMD_head[CharNum]))
 119   2              {
 120   3                  return 0;  //指令头部匹配失败
 121   3              }
 122   2          }
 123   1          return 1;        //指令头部匹配成功
 124   1      }
 125          //比较指令尾部(start:从哪里开始比较，quality:比较多少个字符，CMD_tail[]：要比较的字符串)
 126          bit CompareCMD_tail(unsigned char start,unsigned char quality,char CMD_tail[]) 
 127          {
 128   1          unsigned char CharNum;
 129   1          for(CharNum=0;CharNum<quality;CharNum++)
 130   1          {
 131   2              if(!(buf_string[start+CharNum]==CMD_tail[CharNum]))
 132   2              {
 133   3                  return 0; 
 134   3              }
 135   2          }
 136   1          return 1;
 137   1      }
 138          
 139          bit Deal_UART_RecData()   //处理串口接收数据包函数（成功处理数据包则返回1，否则返回0）
 140          { 
 141   1        //清除发送完成标志位
 142   1      //    == 00  当前功率
 143   1      //    == 01  供电电压
 144   1      //    == 02  供电电流
 145   1      //    == 03  线盘电流
 146   1      //    == 04  最大电流
 147   1      //    == 05  线盘温度
 148   1      //    == 06  锅内温度
 149   1      //    == 07  IGBT频率
 150   1      //    == 08  IGBT温度
 151   1      //    == 09  使用容量
 152   1      //    == 10  机器状态
 153   1      //  int8 i;
 154   1      //  ES=0; //关闭接收中断
 155   1      //  for(i=0;i<15;i++)
 156   1      //  {
 157   1      //    SBUF = buf_string[i];
 158   1      //    while(TI==0);
 159   1      //    TI=0;  
 160   1      //  }
 161   1      //  ES=1; 
 162   1        send_PC('|');
 163   1        if(buf_string[0]==Clinet_headflag&&buf_string[14]=='#')  //进行数据包头尾标记验证
 164   1        {        
 165   2          send_PC('|');
 166   2          if(CompareCMD_tail(1,2,deviceID))
 167   2          {
 168   3            send_PC('|');
 169   3            strncpy(trans_str,buf_string+7,7);
 170   3            trans_int = my_atoi(trans_str);
 171   3            if(CompareCMD_tail(4,2,"00"))     //    == 00  当前功率
 172   3            {
 173   4              Set_Menu1_Value(0,trans_int);
 174   4            }
C51 COMPILER V9.57.0.0   USART                                                             05/31/2018 15:56:47 PAGE 4   

 175   3            else if(CompareCMD_tail(4,2,"01"))//    == 01  供电电压
 176   3            {
 177   4              Set_Menu1_Value(1,trans_int);
 178   4            }
 179   3            else if(CompareCMD_tail(4,2,"02"))//    == 02  供电电流
 180   3            {
 181   4              Set_Menu1_Value(2,trans_int);
 182   4            }
 183   3            else if(CompareCMD_tail(4,2,"03"))//    == 03  线盘电流
 184   3            {
 185   4              Set_Menu1_Value(3,trans_int);
 186   4            }
 187   3            else if(CompareCMD_tail(4,2,"04"))//    == 04  最大电流
 188   3            {
 189   4              Set_Menu1_Value(4,trans_int);
 190   4            }
 191   3            else if(CompareCMD_tail(4,2,"05"))//    == 05  线盘温度
 192   3            {
 193   4              Set_Menu1_Value(5,trans_int);
 194   4            }
 195   3            else if(CompareCMD_tail(4,2,"06"))//    == 06  锅内温度
 196   3            {
 197   4              Set_Menu1_Value(6,trans_int);
 198   4            }
 199   3            else if(CompareCMD_tail(4,2,"07"))//    == 07  IGBT频率
 200   3            {
 201   4              Set_Menu1_Value(7,trans_int);
 202   4            }
 203   3            else if(CompareCMD_tail(4,2,"08"))//    == 08  IGBT温度
 204   3            {
 205   4              Set_Menu1_Value(8,trans_int);
 206   4            }
 207   3            else if(CompareCMD_tail(4,2,"09"))//    == 09  使用容量
 208   3            {
 209   4              Set_Menu1_Value(9,trans_int);
 210   4            }
 211   3            else if(CompareCMD_tail(4,2,"10"))//    == 10  机器状态
 212   3            {
 213   4              Set_Menu1_Value(10,trans_int);
 214   4            }
 215   3          }
 216   2        }
 217   1        return 0;
 218   1      }
 219          
 220          void send_PC(int8 ch)
 221          {
 222   1          SBUF = ch;
 223   1          while(TI==0);
 224   1          TI=0;
 225   1      }
 226          
 227          
 228          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    922    ----
   CONSTANT SIZE    =     33    ----
   XDATA SIZE       =     57      18
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.57.0.0   USART                                                             05/31/2018 15:56:47 PAGE 5   

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
