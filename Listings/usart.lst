C51 COMPILER V9.57.0.0   USART                                                             06/06/2018 15:17:48 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE USART
OBJECT MODULE PLACED IN .\Objects\usart.obj
COMPILER INVOKED BY: D:\pro\keil5\core\C51\BIN\C51.EXE source\usart.c LARGE OPTIMIZE(9,SPEED) BROWSE INCDIR(.\include) D
                    -EBUG OBJECTEXTEND PRINT(.\Listings\usart.lst) TABS(2) OBJECT(.\Objects\usart.obj)

line level    source

   1          #define USART_C_
   2          #include "usart.h"
   3          
   4          
   5          //------------------串口通信协议-----------------//
   6          /*
   7              接收B01_00_0000000#
   8              发送A01_00_0000000#
   9          */
  10          uint8 buf_string[16];               //接收数据
  11          #define deviceID_1Bit '0'           //用于串口通信时，定义本地设备ID的第1位
  12          #define deviceID_2Bit '1'           //用于串口通信时，定义本地设备ID的第2位
  13          #define Service_headflag 'A'        //用于串口通信时，定义数据包头部的验证标记  表示服务器包  发送给服务器
             -的
  14          #define Clinet_headflag 'B'         //用于串口通信时，定义数据包头部的验证标记  表示客户端包  客户需要端接收的
  15          
  16          #define deviceID "01"
  17          
  18          //7-13 为数据 均*100
  19          //数据-9999.99~+9999.99
  20          uint8 DataPackage[16]={Service_headflag,deviceID_1Bit,deviceID_2Bit,'_','0','1','_','X','X','X','X','X','X
             -','X','#'};
  21          uint8 HeartBeat[16]={Service_headflag,deviceID_1Bit,deviceID_2Bit,'_','X','X','_','0','0','0','0','0','0',
             -'0','#'};
  22          
  23          int16 trans_int;
  24          uint8 trans_str[7];
  25          
  26          struct FifoQueue usart_queue;//串口通信仓库
  27          
  28          void Usart_Update()
  29          {
  30   1        if(Take_Queue(&buf_string))
  31   1        {
  32   2          Deal_UART_RecData();
  33   2        }
  34   1      }
  35          void Send_To_Client_Packet(int8 index,int32 num)
  36          {
  37   1        uint32 buf = abs(num);
  38   1        DataPackage[4]=0x30+index%100/10;
  39   1        DataPackage[5]= 0x30+index%10;
  40   1        
  41   1        DataPackage[7] = (num<0?'-':'+');
  42   1        DataPackage[8] = 0x30+buf%1000000/100000;
  43   1        DataPackage[9] = 0x30+buf%100000/10000;
  44   1        DataPackage[10]= 0x30+buf%10000/1000;
  45   1        DataPackage[11]= 0x30+buf%1000/100;
  46   1        DataPackage[12]= 0x30+buf%100/10;
  47   1        DataPackage[13]= 0x30+buf%10;
  48   1          
  49   1        ES=0; //关闭接收中断
  50   1        for(buf=0;buf<15;buf++)
  51   1        {
C51 COMPILER V9.57.0.0   USART                                                             06/06/2018 15:17:48 PAGE 2   

  52   2          SBUF = DataPackage[buf];
  53   2          while(TI==0);
  54   2          TI=0;  
  55   2        }
  56   1        ES=1; 
  57   1      }  
  58          
  59          void SendHeartBeadPacket()
  60          {
  61   1        uint8 i;
  62   1        ES=0; //关闭接收中断
  63   1        for(i=0;i<15;i++)
  64   1        {
  65   2          SBUF = HeartBeat[i];
  66   2          while(TI==0);
  67   2          TI=0;  
  68   2        }
  69   1        ES=1; 
  70   1      }
  71          //定时器1用作波特率发生器
  72          void Init_USART()  
  73          {
  74   1          SCON=0x50;  //串口方式1，使能接收
  75   1          TMOD|=0x20;  //定时器1工作方式2（8位自动重装初值）
  76   1          TMOD&=~0x10;
  77   1          TH1=0xf3;   // 计数器初始值设置，注意波特率是4800的  12M晶振
  78   1          TL1=0xf3;  
  79   1          PCON|=0x80;  //SMOD=1
  80   1          TR1=1;
  81   1          TI=0;
  82   1          RI=0;
  83   1          //PS=1;   //提高串口中断优先级
  84   1          ES=1;  //开启串口中断使能
  85   1        
  86   1          QueueInit(&usart_queue);
  87   1      }
  88          //装入数据
  89          void Interrupt_Queue(uint8 sbuf)
  90          {
  91   1        QueueIn(&usart_queue,sbuf);
  92   1      }
  93          //取出B字开头的15个数据
  94          uint8 Take_Queue(uint8 *newchar)
  95          {
  96   1        uint8 i =0;
  97   1        uint8 temp;
  98   1        if(usart_queue.count < 15)
  99   1        {
 100   2          return 0;//不足15个数据
 101   2        }
 102   1        while(i<15 && QueueOut(&usart_queue,&temp) != QueueEmpty)
 103   1        {
 104   2          if(temp == Clinet_headflag || i != 0)
 105   2          {
 106   3            send_PC(temp);
 107   3            newchar[i] = temp;
 108   3            i++;
 109   3          }
 110   2        }
 111   1        if(i==15)//取了完整的数据
 112   1        {
 113   2          return 1;
C51 COMPILER V9.57.0.0   USART                                                             06/06/2018 15:17:48 PAGE 3   

 114   2        }
 115   1        return 0;
 116   1      }
 117          //比较指令尾部(start:从哪里开始比较，quality:比较多少个字符，CMD_tail[]：要比较的字符串)
 118          bit CompareCMD_tail(unsigned char start,unsigned char quality,char CMD_tail[]) 
 119          {
 120   1          unsigned char CharNum;
 121   1          for(CharNum=0;CharNum<quality;CharNum++)
 122   1          {
 123   2              if(!(buf_string[start+CharNum]==CMD_tail[CharNum]))
 124   2              {
 125   3                  return 0; 
 126   3              }
 127   2          }
 128   1          return 1;
 129   1      }
 130          
 131          bit Deal_UART_RecData()   //处理串口接收数据包函数（成功处理数据包则返回1，否则返回0）
 132          { 
 133   1        //清除发送完成标志位
 134   1      //    == 00  当前功率
 135   1      //    == 01  供电电压
 136   1      //    == 02  供电电流
 137   1      //    == 03  线盘电流
 138   1      //    == 04  最大电流
 139   1      //    == 05  线盘温度
 140   1      //    == 06  锅内温度
 141   1      //    == 07  IGBT频率
 142   1      //    == 08  IGBT温度
 143   1      //    == 09  使用容量
 144   1      //    == 10  机器状态
 145   1      //  
 146   1      //    == 50   输入密码
 147   1      //    == 51   最大功率  
 148   1      //    == 52   最大供电电压
 149   1      //    == 53   最小供电电压
 150   1      //    == 54   最大线盘电流
 151   1      //    == 55   最大线盘温度
 152   1      //    == 56   通用线盘温度
 153   1      //    == 57   最大锅内温度    
 154   1      //    == 58   最大漏料温度  
 155   1      //    == 59   最大IGBT频率
 156   1      //    == 60   最小IGBT频率
 157   1      //    == 61   最大IGBT温度
 158   1      //    == 62   限制工作时间
 159   1      //    == 63   修改密码  
 160   1        if(buf_string[0]==Clinet_headflag&&buf_string[14]=='#')  //进行数据包头尾标记验证
 161   1        {        
 162   2          if(CompareCMD_tail(1,2,deviceID))
 163   2          {
 164   3            strncpy(trans_str,buf_string+7,7);
 165   3            trans_int = my_atoi(trans_str);
 166   3            if(CompareCMD_tail(4,2,"00"))     //    == 00  当前功率
 167   3            {
 168   4              Set_Menu1_Value(0,trans_int);
 169   4              //send_PC('a');
 170   4            }
 171   3            else if(CompareCMD_tail(4,2,"01"))//    == 01  供电电压
 172   3            {
 173   4              Set_Menu1_Value(1,trans_int);
 174   4              //send_PC('b');
 175   4            }
C51 COMPILER V9.57.0.0   USART                                                             06/06/2018 15:17:48 PAGE 4   

 176   3            else if(CompareCMD_tail(4,2,"02"))//    == 02  供电电流
 177   3            {
 178   4              Set_Menu1_Value(2,trans_int);
 179   4              //send_PC('c');
 180   4            }
 181   3            else if(CompareCMD_tail(4,2,"03"))//    == 03  线盘电流
 182   3            {
 183   4              Set_Menu1_Value(3,trans_int);
 184   4            }
 185   3            else if(CompareCMD_tail(4,2,"04"))//    == 04  最大电流
 186   3            {
 187   4              Set_Menu1_Value(4,trans_int);
 188   4            }
 189   3            else if(CompareCMD_tail(4,2,"05"))//    == 05  线盘温度
 190   3            {
 191   4              Set_Menu1_Value(5,trans_int);
 192   4            }
 193   3            else if(CompareCMD_tail(4,2,"06"))//    == 06  锅内温度
 194   3            {
 195   4              Set_Menu1_Value(6,trans_int);
 196   4            }
 197   3            else if(CompareCMD_tail(4,2,"07"))//    == 07  IGBT频率
 198   3            {
 199   4              Set_Menu1_Value(7,trans_int);
 200   4            }
 201   3            else if(CompareCMD_tail(4,2,"08"))//    == 08  IGBT温度
 202   3            {
 203   4              Set_Menu1_Value(8,trans_int);
 204   4            }
 205   3            else if(CompareCMD_tail(4,2,"09"))//    == 09  使用容量
 206   3            {
 207   4              Set_Menu1_Value(9,trans_int);
 208   4            }
 209   3            else if(CompareCMD_tail(4,2,"10"))//    == 10  机器状态
 210   3            {
 211   4              Set_Menu1_Value(10,trans_int);
 212   4            }
 213   3            else if(CompareCMD_tail(4,2,"50"))//    == 50   输入密码
 214   3            {
 215   4              Set_Menu2_Value(0,trans_int);                           
 216   4            }
 217   3            else if(CompareCMD_tail(4,2,"51"))//    == 51   最大功率
 218   3            {
 219   4              Set_Menu2_Value(1,trans_int);                               
 220   4            }  
 221   3            else if(CompareCMD_tail(4,2,"52"))//    == 52   最大供电电压
 222   3            {
 223   4              Set_Menu2_Value(2,trans_int); 
 224   4            }
 225   3            else if(CompareCMD_tail(4,2,"53"))//    == 53   最小供电电压
 226   3            {
 227   4              Set_Menu2_Value(3,trans_int); 
 228   4            }
 229   3            else if(CompareCMD_tail(4,2,"54"))//    == 54   最大线盘电流
 230   3            {
 231   4              Set_Menu2_Value(4,trans_int); 
 232   4            }
 233   3            else if(CompareCMD_tail(4,2,"55"))//    == 55   最大线盘温度
 234   3            {
 235   4              Set_Menu2_Value(5,trans_int); 
 236   4            }
 237   3            else if(CompareCMD_tail(4,2,"56"))//    == 56   通用线盘温度
C51 COMPILER V9.57.0.0   USART                                                             06/06/2018 15:17:48 PAGE 5   

 238   3            {
 239   4              Set_Menu2_Value(6,trans_int); 
 240   4            }
 241   3            else if(CompareCMD_tail(4,2,"57"))//    == 57   最大锅内温度
 242   3            {
 243   4              Set_Menu2_Value(7,trans_int); 
 244   4            }       
 245   3            else if(CompareCMD_tail(4,2,"58"))//    == 58   最大漏料温度  
 246   3            {
 247   4              Set_Menu2_Value(8,trans_int); 
 248   4            }
 249   3            else if(CompareCMD_tail(4,2,"59"))//    == 59   最大IGBT频率
 250   3            {
 251   4              Set_Menu2_Value(9,trans_int); 
 252   4            }
 253   3            else if(CompareCMD_tail(4,2,"60"))//    == 60   最小IGBT频率
 254   3            {
 255   4              Set_Menu2_Value(10,trans_int);  
 256   4            }
 257   3            else if(CompareCMD_tail(4,2,"61"))//    == 61   最大IGBT温度
 258   3            {
 259   4              Set_Menu2_Value(11,trans_int);  
 260   4            }
 261   3            else if(CompareCMD_tail(4,2,"62"))//    == 62   限制工作时间
 262   3            {
 263   4              Set_Menu2_Value(12,trans_int);  
 264   4            }
 265   3            else if(CompareCMD_tail(4,2,"63"))//    == 63   恢复出厂设置
 266   3            {
 267   4              Set_Menu2_Value(13,trans_int);  
 268   4            }       
 269   3          }
 270   2        }
 271   1        return 0;
 272   1      }
 273          
 274          
 275          void send_PC(int8 ch)
 276          {
 277   1          SBUF = ch;
 278   1          while(TI==0);
 279   1          TI=0;
 280   1      }
 281          
 282          
 283          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1300    ----
   CONSTANT SIZE    =     75    ----
   XDATA SIZE       =    123      19
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
